# OS22--死锁的检查与避免

操作系统二-实验二

银行家算法
----------------------------------------------
20200105第一次提交

进程数为3 系统资源数为15 每个进程输入一系列请求，正数为请求占用，负数为请求释放范围为不超过10，以0为结尾
所有数组从1开始计算

每个进程结构体
struct COP
{
    int id;
    int claim[maxapJ]; //动态申请资源数组
    int maxClaim;      //最大资源需求量
    int len = 0;       //申请释放次数
    int allo;          //进程已占资源
    int vps;    //进程完成请求标志，为 0 时表示已完成各次请求
    int vcount; //进程请求次数计数器。其值表示该进程的第几次请求
    int lock;//死锁位 1-产生死锁
} COP[proNum + 1];

选择项option（0-采用银行家算法/1-直接分配）

int Safe(int in, int Ava);//安全函数，in为此时提出请求的进程，Ava为此时系统的可用资源数量，返回值-1表示不安全，返回1 表示安全
安全函数从当前的进程请求开始，一次循环各进程的下一次请求，如果所有进程完成所有请求前存在资源不足的情况，说明该请求不合法，即系统会产生死锁，返回-1，否则返回1

void Bank()；//银行家算法，从当前进程的当前请求开始，执行安全函数，若安全则分配资源，循环进行下一个进程的下一次请求，直到完成所有请求
默认从第一个进程的都一个请求开始，若不安全，则从头选择一个未完成的进程继续分配，当前进程的死锁位置1.

--------------------------------------------------------------------------------------------
